# 第三堂课

[toc]

## 一、内容

1. 本地方法不代理；

2. provider支持方法重载；
   - 修改RpcRequest的method为methodSign；
   - 创建一个工具类方法，用来创建Method的签名；
   - 创建一个ProviderMeta；
   - 修改provider中的 skeletion类型，变成一个多值的map；
   - 在`@PostConstruct`中启动的时候，存放servername和ProviderMeta对；
   - 修改provider的`invoke`方法，根据RpcRequest寻找ProviderMeta；
   - 在provider中的ApplicationRunner中进行测试；

3. consumer支持方法重载；
   - 修改传递方法签名方法；

   **到这里把代码提交一次：添加方法重载的支持。**

4. 将一个方法的参数和返回值都修改为long类型；

   - 写一个工具类，将基本类型转成包装类型；

5. 修改参数：将参数改为Bean；

   - 参数传到Provider，是LinkedHashMap类型；因此要还原类型信息；
   - 更进一步：写一个参数类型为float的方法，看会不会抱错；（同样也报参数不匹配的问题）
   - 打开所有的测试，进行测试；

6. 再加一个新的方法，返回long数组；

   如果使用fastjson，需要对数组的返回值进行处理；

7. 再加两个新的方法，返回int类型数组，和参数为int的数组；

   - 需要处理入参为数组的功能；
   - 将所有测试打开进行测试；

8. 一个接口多个实现类；

   - 只需要修改扫描那块地代码；

9. 添加一个List类型的返回值；



1. 返回值类型；
   - 写一个工具类TypeUtils，把Object转化成指定对象；
     - 判断是否是目标类型的子类型：isAssignableFrom；
     - 8中基本类型和包装类型；

2. 定义一个Bean类型的参数方法；
   - 在consuemr端测试；
   - 在provider端的参数进行类型转换：processArgs；
     - 使用TypeUtils.cas

3. 处理返回值数组类型；

4. 处理参数类型为数组；
   - provider处理数组参数；

5. 一个接口，两个实现类；
  - provider端处理，都放到skeletion中；